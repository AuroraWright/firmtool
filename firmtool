#!/usr/bin/env python

__author__    = "TuxSH"
__copyright__ = "Copyright (c) 2017 TuxSH"
__license__   = "BSD"
__version__   = "0.1"

"""
Parses, extracts, and builds 3DS firmware files
"""

from struct import pack, unpack, unpack_from
from binascii import hexlify, unhexlify

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
import argparse
import sys
import os

def keyscrambler(keyX, keyY):
    #http://www.falatic.com/index.php/108/python-and-bitwise-rotation
    rol = lambda val, r_bits, max_bits: \
        (val << r_bits%max_bits) & (2**max_bits-1) | \
        ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))
    return rol((rol(keyX, 2, 128) ^ keyY) + 0x1FF9E9AAC5FE0408024591DC5D52768A, 87, 128)

def exportP9(basePath, data):
    if not os.path.isdir(os.path.join(basePath, "modules")):
        os.mkdir(os.path.join(basePath, "modules"))

    pos = data.find(b"Process9") - 0x200

    if pos < 0: return
    size = unpack_from("<I", data, pos + 0x104)[0] * 0x200
    with open(os.path.join(basePath, "modules", "Process9.cxi"), "wb+") as f:
        f.write(data[pos : pos + size])


#
# Copyright (c) 2009 Forest Belton
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

def extractElf(elfFile):
    elfFile.seek(0)
    hdr = elfFile.read(52)

    if len(hdr) != 52:
        raise ValueError("failed to read firm header")

    ident, e_type, machine, version, entry, phoff, shoff, e_flags, ehsize, \
    phentsize, phnum, shentsize, shnum, shstrndx = unpack("<16s2H5I6H", hdr)

    if machine != 40:
        raise ValueError("machine type not ARM")

    if version != 1:
        raise ValueError("invalid ELF version")

    if ehsize != 52:
        raise ValueError("invalid ELF header size")

    if phnum == 0:
        raise ValueError("no program headers")

    elfFile.seek(phoff)
    addr, sz = 0, 0
    datalst = []
    for i in range(phnum):
        phdr = elfFile.read(32)
        p_type, offset, vaddr, paddr, filesz, memsz, p_flags, p_align = unpack("<8I", phdr)
        if p_type != 1 or filesz == 0: # not loadable or BSS
            continue

        # Use first found address and read contiguous sections
        if addr == 0:
            addr = paddr
        else:
            if paddr != addr + size:
                continue

        elfFile.seek(offset)
        pdata = elfFile.read(filesz)
        if len(pdata) != filesz:
            raise ValueError("failed to read program header segment")
        datalst.append(pdata)
        datalst.append(b'\x00' * (memsz - filesz))

        sz += memsz

    return entry, addr, b''.join(datalst)

class FirmSectionHeader(object):
    def check(self):
        off = self.offset
        if self.copyMethod == 0 and (1 << 20) > self.size >= 0x800+0xA00 and self.address == 0x08006000:
            if self.sectionData[0x50 : 0x53] == b"K9L":
                self.guessedType = self.sectionData[0x50 : 0x54].decode("ascii")
            elif self.sectionData[0x50 : 0x54] == b"\xFF\xFF\xFF\xFF":
                self.guessedType = "K9L0"
        elif self.copyMethod == 0 and (1 << 20) > self.size >= 0xA00 and self.address == 0x08006800:
            self.guessedType = "Kernel9"
        elif self.copyMethod == 1 and self.size >= 0xA00:
            if self.sectionData[0x100 : 0x104] == b"NCCH":
                self.guessedType = "Kernel11 modules"

        H = hashes.Hash(hashes.SHA256(), backend=default_backend())
        H.update(self.sectionData)
        self.hashIsValid = self.hash == H.finalize()

    def __init__(self, n, data = None):
        self.num = n
        hdrData = b'\x00'* 0x30 if data is None else data[0x40 + 0x30 * n : 0x40 + 0x30 * (n + 1)]
        self.offset, self.address, self.size, self.copyMethod, self.hash = unpack("<4I32s", hdrData)
        self.sectionData = b'' if self.size == 0 else data[self.offset : self.offset + self.size]
        self.guessedType = ''
        self.hashIsValid = True
        if not (data is None): self.check()

    def setData(self, data):
        self.sectionData = data + b'\xFF' * (16 - (len(data) % 16))
        self.size = len(self.sectionData)
        self.guessedType = ''
        self.hashIsValid = True
        H = hashes.Hash(hashes.SHA256(), backend=default_backend())
        H.update(self.sectionData)
        self.hash = H.finalize()

    def buildHeader(self):
        return pack("<4I32s", self.offset, self.address, self.size, self.copyMethod, self.hash)

    def export(self, basePath, extractModules = False, secretSector = None):
        if self.guessedType == "Kernel11 modules" and extractModules:
            pos = 0

            if not os.path.isdir(os.path.join(basePath, "modules")):
                os.mkdir(os.path.join(basePath, "modules"))
            while pos < self.size:
                size = unpack_from("<I", self.sectionData, pos + 0x104)[0] * 0x200
                name = self.sectionData[pos + 0x200: pos + 0x208].decode("ascii")
                name = "{0}.cxi".format(name[:name.find('\x00')])
                with open(os.path.join(basePath, "modules", name), "wb+") as f:
                    f.write(self.sectionData[pos : pos + size])
                pos += size

            with open(os.path.join(basePath, "section{0}.bin".format(self.num)), "wb+") as f:
                f.write(self.sectionData)

        elif self.guessedType.startswith("K9L") and secretSector is not None:
            encKeyX = self.sectionData[:0x10] if self.guessedType[3] == '0' else self.sectionData[0x60 : 0x70]
            key0x11 = secretSector[:0x10] if self.guessedType[3] != '2' else secretSector[0x10 : 0x20]

            de = Cipher(algorithms.AES(key0x11), modes.ECB(), backend=default_backend()).decryptor()
            keyX = de.update(encKeyX) + de.finalize()

            keyY = self.sectionData[0x10 : 0x20]

            ctr = int(hexlify(self.sectionData[0x20 : 0x30]), 16)
            key = unhexlify("{0:032X}".format(keyscrambler(int(hexlify(keyX), 16), int(hexlify(keyY), 16))))

            sizeDec = self.sectionData[0x30 : 0x38].decode("ascii")
            size = int(sizeDec[:sizeDec.find('\x00')])

            data = self.sectionData
            if 0x800 + size <= self.size:
                de = Cipher(algorithms.AES(key), modes.CTR(ctr), backend=default_backend()).decryptor()
                data = self.sectionData[:0x800] + de.update(self.sectionData[0x800 : 0x800 + size]) + de.finalize() + self.sectionData[0x800+size:] 
                exportP9(basePath, data)

            with open(os.path.join(basePath, "section{0}.bin".format(self.num)), "wb+") as f:
                f.write(data)

        elif self.guessedType == "Kernel9":
            exportP9(basePath, self.sectionData)

            with open(os.path.join(basePath, "section{0}.bin".format(self.num)), "wb+") as f:
                f.write(self.sectionData)

        else:
            with open(os.path.join(basePath, "section{0}.bin".format(self.num)), "wb+") as f:
                f.write(self.sectionData)

    def __str__(self):
        types = ("NDMA", "XDMA", "memcpy")
        return """Copy type:\t{0}{1}
Offset:\t\t0x{2:08X}
Address:\t0x{3:08X}
Size:\t\t0x{4:08X}
Hash:\t\t{5:032X}{6}""".format(types[self.copyMethod] if 0 <= self.copyMethod <= 2 else "invalid ({0})".format(self.copyMethod),
        "\nGuessed type:\t{0}".format(self.guessedType) if self.guessedType else "",
        self.offset, self.address, self.size, int(hexlify(self.hash), 16), " (invalid)" if not self.hashIsValid else "")


class Firm(object):
    def check(self):
        self.arm11EntrypointFound, self.arm9EntrypointFound = False, False
        for i in range(4):
            sec = self.sections[i]
            self.arm11EntrypointFound = self.arm11EntrypointFound or sec.address <= self.arm11Entrypoint < sec.address + sec.size
            self.arm9EntrypointFound = self.arm9EntrypointFound or sec.address <= self.arm9Entrypoint < sec.address + sec.size
            sec.check()

    def export(self, basePath, exportModules = False, secretSector = None):
        for i in range(4):
            if self.sections[i].size != 0:
                self.sections[i].export(basePath, exportModules, secretSector)

    def __init__(self, data = None):
        if data is None:
            self.priority, self.arm11Entrypoint, self.arm9Entrypoint = 0, 0, 0
            self.sections = [FirmSectionHeader(i) for i in range(4)]
            self.reserved, self.signature = b'\x00'* 0x30, b'\x00'* 0x100
        else:
            if data[:4] != b"FIRM":
                raise ValueError("Not a FIRM file")

            self.priority, self.arm11Entrypoint, self.arm9Entrypoint, self.reserved = unpack_from("<3I48s", data, 4)
            self.sections = [FirmSectionHeader(i, data) for i in range(4)]
            self.signature = data[0x100 : 0x200]
            self.check()

    def setSectionData(self, n, data):
        self.sections[n].setData(data)

        off = 0x200
        for i in range(4):
            if self.sections[i].size != 0:
                self.sections[i].offset = off
                off += self.sections[i].size

    def build(self):
        hdr1 = pack("<3I48s", self.priority, self.arm11Entrypoint, self.arm9Entrypoint, self.reserved)
        hdr2 = b''.join(self.sections[i].buildHeader() for i in range(4))
        secs = b''.join(self.sections[i].sectionData for i in range(4))
        return b''.join((b"FIRM", hdr1, hdr2, self.signature, secs))

    def __str__(self):
        hdr = """Priority:\t\t{0}

ARM9 entrypoint:\t0x{1:08X}{2}
ARM11 entrypoint:\t0x{3:08X}{4}

RSA-2048 signature:\t{5:0256X}

""".format(self.priority, self.arm9Entrypoint, " (invalid)" if not self.arm9EntrypointFound else "",
                   self.arm11Entrypoint, " (invalid)" if not self.arm11EntrypointFound else "", int(hexlify(self.signature), 16))

        #fmt_section = lambda n: "Section {0}:\n{1}".format(n), str(self.sections[n])))
        secs = '\n\n'.join("Section {0}:\n{1}".format(i, ''.join('\t' + l for l in str(self.sections[i]).splitlines(True)))
                for i in range(4) if self.sections[i].size != 0)
        return hdr+secs


def parseFirm(args):
    print(Firm(args.infile.read()))

def extractFirm(args):
    firmObj = Firm(args.infile.read())
    firmObj.export(args.outdir, args.export_modules, None if args.secret_sector is None else args.secret_sector.read())

def buildFirm(args):
    if not (len(args.section_data) == len(args.section_copy_methods)):
        raise ValueError("number of sections not matching")
    elif len(args.section_addresses) > 4 or len(args.section_data) > 4 or len(args.section_copy_methods) > 4:
        raise ValueError("too many sections")

    addrpos = 0

    firmObj = Firm()
    firmObj.arm9Entrypoint = args.arm9_entrypoint
    firmObj.arm11Entrypoint = args.arm11_entrypoint

    for i in range(len(args.section_copy_methods)):
        magic = args.section_data[i].read(4)
        args.section_data[i].seek(0)

        if len(magic) == 4 and magic == b"\x7FELF":
            entry, firmObj.sections[i].address, data = extractElf(args.section_data[i])
            firmObj.arm9Entrypoint = entry if firmObj.arm9Entrypoint == 0 and args.section_copy_methods[i] == "NDMA" else firmObj.arm9Entrypoint
            firmObj.arm11Entrypoint = entry if firmObj.arm11Entrypoint == 0 and args.section_copy_methods[i] == "XDMA" else firmObj.arm11Entrypoint
            firmObj.setSectionData(i, data)
        else:
            if addrpos >= len(args.section_addresses):
                raise argparse.ArgumentError("missing section addresses")
            firmObj.sections[i].address = args.section_addresses[addrpos]
            firmObj.sections[i].copyMethod = ("NDMA", "XDMA", "memcpy").index(args.section_copy_methods[i])
            firmObj.setSectionData(i, args.section_data[i].read())
            addrpos += 1

    firmObj.check()
    if not firmObj.arm9EntrypointFound:
        raise ValueError("invalid or missing ARM9 entrypoint")

    if not firmObj.arm11EntrypointFound:
        raise ValueError("invalid or missing ARM11 entrypoint")

    args.outfile.write(firmObj.build())

def Uint32(s):
    N = 0
    try:
        N = int(s, base=0)
    except:
        raise argparse.ArgumentTypeError("invalid unsigned 32-bit integer")

    if not(0 <= int(N) < 2**32):
        raise argparse.ArgumentTypeError("invalid unsigned 32-bit integer")
    return N

if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog="firmtool", description="Parses, extracts, and builds 3DS firmware files.")
    subparsers = parser.add_subparsers(help="sub-command help")

    parser_parse = subparsers.add_parser("parse")
    parser_parse.set_defaults(func=parseFirm)
    parser_parse.add_argument("infile", type=argparse.FileType("rb"))

    parser_extract = subparsers.add_parser("extract")
    parser_extract.set_defaults(func=extractFirm)
    parser_extract.add_argument("infile", help="Input firmware file", type=argparse.FileType("rb"))
    parser_extract.add_argument("outdir", help="Output directory (current directory by default)", nargs='?', default='.')
    parser_extract.add_argument("-m", "--export-modules", help="Export k11 modules and Process9 (when applicable and if possible)",
                                action="store_true")
    parser_extract.add_argument("-s", "--secret-sector", help="Path to decrypted secret sector, to decrypt the arm9 binary (when applicable)",
                                type=argparse.FileType("rb"))

    parser_build = subparsers.add_parser("build")
    parser_build.set_defaults(func=buildFirm)
    parser_build.add_argument("outfile", help="Output firmware file", type=argparse.FileType("wb+"))
    parser_build.add_argument("-n", "--arm9-entrypoint", help="ARM9 entrypoint (deduced from the first ELF file having an entrypoint and corresponding to a NDMA-copied \
    section, otherwise required)", type=Uint32, default=0) # "nine"
    parser_build.add_argument("-e", "--arm11-entrypoint", help="ARM11 entrypoint (deduced from the first ELF file having and entrypoint and corresponding to a XDMA-copied \
    section, otherwise required)", type=Uint32, default=0) # "eleven"
    parser_build.add_argument("-D", "--section-data", help="Files containing the data of each section (required)", type=argparse.FileType("rb"), nargs='+', required=True)
    parser_build.add_argument("-A", "--section-addresses", help="Loading address of each section (inferred from the corresponding ELF file, otherwise required)",
    type=Uint32, nargs='+', default=[])
    parser_build.add_argument("-C", "--section-copy-methods", help="Copy method of each section (NDMA, XDMA, memcpy) (required)", choices=("NDMA", "XDMA", "memcpy"), nargs='+', required=True)

    args = parser.parse_args()

    # http://bugs.python.org/issue16308 it's still not fixed, WTF are they doing ?!
    try:
        getattr(args, "func")
    except AttributeError:
        parser.print_help()
        sys.exit(0)

    args.func(args)
